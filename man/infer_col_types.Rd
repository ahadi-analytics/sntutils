% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/infer_col_types.R
\name{infer_col_types}
\alias{infer_col_types}
\title{Infer column types using readr, then layer factor detection}
\usage{
infer_col_types(
  data,
  max_levels = 50,
  max_unique_ratio = 0.2,
  protect_patterns = c("id$", "uid$", "code$", "ref$", "key$"),
  keep_leading_zero_chars = TRUE,
  prefer_logical_for_binary = TRUE,
  apply = FALSE,
  return = c("data", "both", "plan")
)
}
\arguments{
\item{data}{data.frame or tibble.}

\item{max_levels}{integer. max distinct values for factor. default 50.}

\item{max_unique_ratio}{numeric (0, 1]. max unique/n for factor. default 0.2.}

\item{protect_patterns}{character regexes for protected names.
default c("id$", "uid$", "code$", "ref$", "key$").}

\item{keep_leading_zero_chars}{logical. keep character if any value has
leading zeros in digit-only strings. default TRUE.}

\item{prefer_logical_for_binary}{logical. kept for api compatibility, not
used when delegating to readr. default TRUE.}

\item{apply}{logical. if TRUE, apply factor conversions on top of parsed
types. default FALSE.}

\item{return}{one of "data", "both", "plan". default "data".}
}
\value{
invisible object depending on \code{return}:
\itemize{
\item "data": tibble of parsed data (and factors if apply = TRUE)
\item "both": list(plan = tibble, data = tibble as above)
\item "plan": tibble only
}
}
\description{
use readr::type_convert() to infer non-factor types (numeric, integer, date,
datetime, logical), then propose factors via low-cardinality rules. protect
id-like names and leading-zero codes. return the dataset by default, and
include the metadata plan only when requested.
}
\examples{
df <- tibble::tibble(
  id  = c("001", "002", "003"),
  sex = c("M", "F", "F"),
  age = c("1", "2", "3"),
  dt  = c("2024-01-01 12:00:00", "2024-01-02 00:00:00",
          "2024-01-03 01:02:03")
)

# just get the dataset (parsed + factors)
dat <- infer_col_types(df, apply = TRUE, return = "data")

# get dataset and plan
both <- infer_col_types(df, apply = TRUE, return = "both")
both$plan |> dplyr::select(name, current_type, proposed_type, rule)
dplyr::glimpse(both$data)
}
