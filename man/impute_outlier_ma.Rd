% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/outlier_detection.R
\name{impute_outlier_ma}
\alias{impute_outlier_ma}
\title{Impute outliers using moving average from adjacent time points}
\usage{
impute_outlier_ma(x, threshold)
}
\arguments{
\item{x}{Numeric vector of values. Should be sorted by time within groups
before calling this function.}

\item{threshold}{Numeric scalar. Values strictly greater than this threshold
are considered outliers and will be imputed.}
}
\value{
Numeric vector of the same length as \code{x}, with outliers replaced by
the rounded moving average of valid adjacent values. If no valid adjacent
values exist, the original value is retained.
}
\description{
Replaces outlier values (those exceeding a threshold) with the moving average
of adjacent non-outlier values. Useful for smoothing time series data where
outliers should be replaced with locally consistent values rather than removed.
}
\details{
The function works as follows:
\enumerate{
\item For each value, it checks if the previous and next values are non-outliers
(i.e., <= threshold)
\item If a value exceeds the threshold, it calculates the mean of valid adjacent
values (previous and/or next)
\item The outlier is replaced with the rounded moving average
\item If no valid adjacent values exist (both neighbors are also outliers or NA),
the original value is kept
}

This approach preserves local trends while removing spike anomalies. It's
particularly useful for time series where outliers represent data errors
rather than true signal.
}
\examples{
# simple example with one outlier
x <- c(10, 12, 100, 14, 11)
impute_outlier_ma(x, threshold = 50)
# Returns: c(10, 12, 13, 14, 11) - the 100 is replaced with mean(12, 14) = 13

# consecutive outliers - only outer edges get imputed
x <- c(10, 100, 200, 15)
impute_outlier_ma(x, threshold = 50)
# Returns: c(10, 10, 15, 15) - each outlier uses its one valid neighbor

# use with dplyr for grouped time series
\dontrun{
data |>
  dplyr::arrange(adm2, date) |>
  dplyr::group_by(adm2) |>
  dplyr::mutate(
    cases_imputed = impute_outlier_ma(cases, threshold = upper_bound)
  ) |>
  dplyr::ungroup()
}

}
